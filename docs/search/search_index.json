{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Comencem!</p>"},{"location":"1.intro/","title":"1. Introducci\u00f3","text":""},{"location":"1.intro/#1-introduccio-a-godot-i-preparacio-del-projecte","title":"1. Introducci\u00f3 a Godot i preparaci\u00f3 del projecte","text":""},{"location":"1.intro/#que-es-godot","title":"Qu\u00e8 \u00e9s Godot?","text":"<p>Godot \u00e9s un motor de jocs lliure i de codi obert, ideal per a crear videojocs 2D i 3D. T\u00e9 una interf\u00edcie intu\u00eftiva, suport multiplataforma i un llenguatge de programaci\u00f3 propi anomenat GDScript, inspirat en Python.</p> <p>Desc\u00e0rrega de Godot</p> <p>Podem descarregar Godot des de la seua web godotengine.org. La versi\u00f3 actual \u00e9s la 4.4.1.</p> <p>Una vegada a la secci\u00f3 de desc\u00e0rregues podem tiar entre:</p> <ul> <li>Godot Engine: La versi\u00f3 est\u00e0ndard, que utilitza el llenguatge natiu GDScript.</li> <li>Godot Engine .NET: La versi\u00f3 per a .NET que fa \u00fas de C# com a llenguatge de programaci\u00f3.</li> </ul> <p>Triarem la versi\u00f3 est\u00e0ndard, i com veurem, \u00e9s un fitxer comprimit amb menys de 100mb.</p> <p>Una vegada descarregat nom\u00e9s haurem de descomprimir el .zip i llan\u00e7ar l'executable resultant.</p>"},{"location":"1.intro/#entorn-de-treball","title":"Entorn de treball","text":"<p>En obrir Godot trobem el gestor de projectes, des d\u2019on podem crear un projecte nou o obrir-ne un existent.</p> <p>Per tal de crear un projecte:</p> <ol> <li>Obrim Godot i seleccionem +Crea per crear un nou projecte.</li> <li>Li donem un nom (per exemple <code>taller_godot</code>)</li> <li>Triem la carpeta on es guardar\u00e0.</li> <li>Seleccionem Renderer: <code>Forward+</code> (els altres s\u00f3n optimitzacions per a m\u00f2bils i un mode per compatibilitat amb sistemes amb menys recursos)</li> <li>Cliquem Crea</li> </ol> <p></p> <p>Projecte de base</p> <p>Com que ja se us proporciona un projecte de base, nom\u00e9s huareu de seleccionar Importa per obrir el projecte.</p>"},{"location":"1.intro/#leditor-de-godot","title":"L'editor de Godot","text":"<p>L'editor de Godot t\u00e9 el seg\u00fcent aspecte:</p> <p></p> <p>On trobem els seg\u00fcents elements:</p> <ul> <li>Menu principal: Es tracta del men\u00fa de l'aplicaci\u00f3 des d'on accedir a les funcionalitats principals del programa, com obrir, guardar projectes, configurar l\u2019editor, etc.</li> <li>Workspaces: Godot compta amb diferents espais de treball (2D, 3D, Script, AssetLib) que podem canviar segons el tipus de tasca que estem realitzant. Cada espai de treball est\u00e0 estructurat per als diferents tipus de treball que estem fent.</li> <li>Barra d'eines (Toolbar): La barra d\u2019eines ofereix acc\u00e9s r\u00e0pid a les eines i les funcions m\u00e9s comunes, com moure, rotar, escalar objectes, entre d\u2019altres. Aquesta barra variar\u00e0 en funci\u00f3 de l'espai de treball on ens trobem.</li> <li>Playtest buttons: Ens permeten controlar l'execuci\u00f3 del projecte que estem desenvolupant per provar-lo des del mateix editor.</li> <li>Vista de l\u2019escena i Viewport: \u00c9s la zona principal de treball, on podem veure i editar les escenes del joc. En el mode 2D, veiem una vista plana, mentre que en el mode 3D, disposarem d'una vista tridimensional.</li> <li>Panell inferior (Bottom Panel): Cont\u00e9 diverses eines d'utilitat com la consola d'eixida, el depurador, o els editors d'\u00e0udio i animacions.</li> <li>Tab de l\u2019arbre de l\u2019escena: Mostra la jerarquia d'objectes (nodes) de l'escena actual, des d'on podem gestionar els nodes d'aquesta.</li> <li>Tab de recursos del projecte: Ens mostra els recursos del projecte, tals com scripts, imatges, sons, etc. \u00c9s com un explorador de fitxers integrat dins de l\u2019editor.</li> <li>Tab amb l\u2019inspector: Ens mostra les propietat de l'objecte (node) seleccionat, i ens permet la seua modificaci\u00f3.</li> </ul>"},{"location":"1.intro/#configuracio-inicial-del-projecte","title":"Configuraci\u00f3 inicial del projecte","text":"<p>Per a jocs 2D, i especialment si utilitzem p\u00edxel art, \u00e9s important establir b\u00e9 la resoluci\u00f3 i escalar correctament la finestra.</p> <p>Configuraci\u00f3 recomanada per al taller: * Resoluci\u00f3 base: <code>800 x 450</code> (Ideal per p\u00edxel art) * Resoluci\u00f3 de finestra: <code>1280 x 720</code> (Escalat m\u00e9s clar en pantalles modernes)</p> <p>Per tal de configurar el projecte:</p> <ul> <li>Accedim a <code>Project \u2192 Project Settings \u2192 Display \u2192 Window \u2192 Size</code>, i establim:<ul> <li><code>Viewport Width</code>: <code>800</code></li> <li><code>Viewport Height</code>: <code>450</code></li> <li><code>Window Width Override</code>: <code>1280</code> (cal activat Advanced Settings)</li> <li><code>Window Height Override</code>: <code>720</code> (cal activat Advanced Settings)</li> <li><code>Stretch \u2192 Mode</code> : ViewPort (per ajustar la finestra al ViewPort)</li> </ul> </li> </ul> <p>A m\u00e9s, per a l'escalat de p\u00edxels (important per p\u00edxel art):</p> <ul> <li>A <code>Rendering \u2192 Textures \u2192 Canvas Texture \u2192 Default Texture Filter</code>: seleccionem <code>Nearest</code>: Aix\u00f2 evita que els p\u00edxels apareguen difuminats quan escalen.</li> </ul> <p>Projecte preconfigurat</p> <p>Tot i que ja tindreu configurat el projecte, comproveu que aquests par\u00e0metres estan correctament ajustats.</p>"},{"location":"1.intro/#estructura-basica-de-godot","title":"Estructura b\u00e0sica de Godot","text":"<p>Godot treballa amb escenes i nodes</p> <ul> <li>Una Escena \u00e9s una unitat de joc: pot ser un personatge, un nivell, un bot\u00f3\u2026</li> <li>Cada escena es forma amb Nodes, que poden ser visuals (2D/3D), de col\u00b7lisi\u00f3, sons, c\u00e0meres, scripts...</li> </ul> <p>...i en Godot no ens oblidem de la POO</p> <p>En Godot, cada node \u00e9s una inst\u00e0ncia d'una classe, i podem crear jerarquies i fer \u00fas de l\u2019her\u00e8ncia per estructurar millor el nostre codi.</p> <p>El tipus de node que afegim a l\u2019escena determina les funcionalitats que tindr\u00e0 aquest node. A m\u00e9s, les classes que s\u2019utilitzen en Godot segueixen un model d'her\u00e8ncia que es reflecteix directament en les jerarquies de nodes.</p>"},{"location":"1.intro/#estructura-del-node-jugador","title":"Estructura del node jugador","text":"<p>Obri l'escena del jugador (<code>Characters/Player/player.tscn</code>), i observa que aquesta t\u00e9 la seg\u00fcent estructura:</p> <pre><code>Player (CharacterBody2D)\n   \u2514\u2500\u2500 AnimatedSprite2D\n   \u2514\u2500\u2500 CollisionShape2D\n</code></pre> <p>\u00c9s a dir, l'escena del jugador est\u00e0 formada per un node que hem anomenat <code>Player</code> i que \u00e9s un node de tipus <code>CharacterBody2D</code>. Aquest node cont\u00e9 dos nodes fills: <code>AnimatedSprite2D</code> i <code>CollissionShape2D</code>.</p> <p>La relaci\u00f3 entre aquests nodes \u00e9s una relaci\u00f3 de composici\u00f3 o cont\u00e9-un:</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    Player *-- AnimatedSprite2D\n    Player *-- CollissionShape2D\n\n    class Player\n    &lt;&lt;CharacterBody2D&gt;&gt; Player</code></pre> <p>Des del node Player podem gestionar els nodes <code>AnimatedSprite2D</code> i <code>CollissionShape2D</code>. A m\u00e9s, aquests nodes fills podrien tindre altres nodes fills, formant una jerarquia en forma d'arbre (coneguda com l'arbre de l'escena)</p> <p>Hem dit que cada tipus de node determina la funcionalitat d'aquest. So fem clic en el bot\u00f3 <code>+</code> situat a baix la pestanya d'Escena per afegir un nou node, podrem veure tota la jerarquia d'aquests:</p> <p></p> <p>Observeu que els diferents tipus de nodes s'organitzen en forma d'arbre, i que podem anar aprofundint en aquest arbre per trobar el node que necessitem, o b\u00e9 podem buscar-lo fent servir la barra superior. En aquest selector hem de tindre en compte alguns detalls:</p> <ul> <li>La relaci\u00f3 entre els diferents nodes que apareixen aci \u00e9s una relaci\u00f3 d'her\u00e8ncia. \u00c9s a dir, cada node intern de l'arbre deriva o descendeix del node que apareix com a pare.</li> <li>Els nodes tenen una icona que els representa. El color d'aquesta determina el tipus: El color blau indica que s\u00f3n nodes per a 2D, el roig per a 3D, i el verd que s\u00f3n nodes per al disseny d'interf\u00edcies.</li> <li>Alguns nodes apareixen en gris. Aix\u00f2 vol dir que es tracta de classes abstractes. \u00c9s a dir, que no es poden instanciar directament.</li> <li>Cada classe defineix unes funcionalitats i propietats concretes. Des de l'editor del joc, i des del codi anem a poder accedir tant a les propietats del node com a les propietats dels seus nodes ascendents.</li> </ul> <p>Fem una prova...</p> <p>Des de la finestra de selecci\u00f3 observeu quin \u00e9s el cam\u00ed en l'arbre fins arribar, perr exemple al node de tipus AnimatedSprite.</p> <p>Fixem-nos tamb\u00e9 en l'Inspector, ubicat a la part dreta de l'editor. Des d'aquest apart de la intef\u00edcie podem ajustar les diferents propietats del node seleccionat.</p> <p>Contrasteu el cam\u00ed que hem vist en la finestra anterior per arribar al node AnimatedSprite2D amb l'organitzaci\u00f3 de l'Inspector per a aquest node. Quines conclussions podem extraure?</p> <p>Una vegada hem ent\u00e8s b\u00e9 la relaci\u00f3 entre els diferents tipus de nodes, veiem per a qu\u00e8 serveixen aquests:</p> <ul> <li><code>Node</code>: La classe m\u00e9s b\u00e0sica que permet la creaci\u00f3 d'escenes.</li> <li><code>CanvasItem</code>: Classe per a nodes que poden ser dibuixats (en 2D).</li> <li><code>Node2D</code>: Hereta de <code>CanvasItem</code> i \u00e9s la classe b\u00e0sica per a nodes en un espai 2D (per exemple, sprites, c\u00e0meres, etc.).</li> <li><code>CollisionObject2D</code>: Hereta de <code>Node2D</code> i \u00e9s la classe base per a objectes que poden tenir col\u00b7lisions en l'espai 2D.</li> <li><code>PhysicsBody2D</code>: Hereta de <code>CollisionObject2D</code> i \u00e9s la classe base per a objectes f\u00edsics en el m\u00f3n 2D (cossos que interactuen amb la f\u00edsica).</li> <li><code>CharacterBody2D</code>: Especialitzaci\u00f3 de <code>PhysicsBody2D</code>, dissenyada per a personatges que interact\u00faen en el joc o entitats controlades per l'usuari. A m\u00e9s, proporciona funcionalitats avan\u00e7ades per al moviment (com el m\u00e8tode <code>move_and_slide</code> que veurem despr\u00e9s).</li> </ul> <p>Com hem vist a l'Inspector, quan utiliem un node tenim acc\u00e9s a totes les propietats i funcions de les classes superior. A mode d'exemple, per a un CharacterBody2D podem ajustar propietats de classes ascendents com:</p> <ul> <li><code>Node2D</code>: Ens permet treballar amb la posici\u00f3, rotaci\u00f3 i escala del node (propietats <code>position</code>, <code>rotation</code>, <code>scale</code>)</li> <li><code>CollisionObject2D</code>: Ens permet gestionar col\u00b7lisions en 2D (m\u00e8todes <code>add_collision_exception_with()</code>, <code>set_collision_layer()</code>, <code>set_collision_mask()</code>)</li> <li><code>PhysicsBody2D</code>: Ens permet treballar amb la f\u00edsica 2D (gravetat, moviment, etc.) (m\u00e8todes com <code>apply_impulse()</code> o propietats com <code>velocity</code>, <code>linear_velocity</code>).</li> <li><code>CharacterBody2D</code>: Ens permet gestionar personatges jugables amb funcionalitats com el m\u00e8tode <code>move_and_slide()</code>, per despla\u00e7ar el jugador o <code>is_on_floor()</code> per saber si \u00e9s a terra.</li> </ul>"},{"location":"1.intro/#diagrama-de-classes-complet","title":"Diagrama de classes complet","text":"<p>Tenint en compte tot el que hem vist, el diagrama de classes quedaria de la seg\u00fcent forma:</p> <pre><code>---\n  config:\n    class:\n      hideEmptyMembersBox: true\n---\nclassDiagram\n    Node &lt;|-- CanvasItem\n    CanvasItem &lt;|-- Node2D\n    Node2D &lt;|-- CollisionObject2D\n    CollisionObject2D &lt;|-- PhysicsBody2D\n    PhysicsBody2D &lt;|-- CharacterBody2D\n\n    class Node {\n        +name\n    }\n\n    class CanvasItem {\n    }\n\n    class Node2D {\n        +position\n        +rotation\n        +scale\n    }\n\n    class CollisionObject2D {\n    }\n\n    class PhysicsBody2D {\n        +apply_impulse()\n        +velocity\n        +linear_velocity\n    }\n\n    class CharacterBody2D {\n        +move_and_slide()\n        +is_on_floor()\n        +velocity\n    }\n\n    AnimatedSprite2D &lt;|-- Node2D\n    CollissionShape2D &lt;|-- Node2D\n\n    CharacterBody2D *-- AnimatedSprite2D\n    CharacterBody2D *-- CollissionShape2D\n\n</code></pre> <p>Com veiem:</p> <ul> <li>La nostra escena Player consisteix en un node principal CharacterBody2D que \u00e9s una composici\u00f3 d'AnimatedSprite2D i de CollissionShape2D. </li> <li>Cadascuna d'aquestes classes t\u00e9 el seu comportament independent, per\u00f2 en conjunt formen el personatge jugable.</li> <li>Quan creem un node CharacterBody2D, autom\u00e0ticament estem adquirint les propietats i funcions de PhysicsBody2D i CollisionObject2D, que ens permetran treballar amb f\u00edsica i col\u00b7lisions de manera m\u00e9s detallada.Aix\u00ed, podem configurar les propietats f\u00edsiques (com la gravetat o la velocitat) a CharacterBody2D, per\u00f2 tamb\u00e9 tenim acc\u00e9s a funcions de col\u00b7lisi\u00f3 i moviment que provenen de les classes superiors.</li> </ul>"},{"location":"2.personatge/","title":"2. Personatge","text":""},{"location":"2.personatge/#el-personatge-principal","title":"El Personatge Principal","text":"<p>L'escena del personatge ja cont\u00e9 la seg\u00fcent estructura b\u00e0sica:</p> <pre><code>Player (CharacterBody2D)\n   \u2514\u2500\u2500 AnimatedSprite2D\n   \u2514\u2500\u2500 CollisionShape2D\n</code></pre> <ol> <li>CharacterBody2D: El node principal, que gestiona el moviment i les interaccions f\u00edsiques del personatge.</li> <li>AnimatedSprite2D: Un node fill que mostra les animacions del personatge (Idle, Running, Jumping, etc.). </li> <li>CollisionShape2D: Un node fill que defineix la forma de col\u00b7lisi\u00f3 del personatge.</li> </ol> <p>Sobre l'ordre dels nodes</p> <p>Cal tindre en compte que l'ordre que establim entre els nodes fills determina com vorem el node pare a l'editor. En aquest cas, veurem el CollissionShape per sobre de l'AnimatedSprite.</p> <p>Sobre la posici\u00f3 del personatge</p> <p>\u00c9s important que el personatge estiga centrat en la posici\u00f3 (0,0).</p> <p>Fixeu-vos que el personatge es troba ubicat entr dues l\u00ednies: una horitzontal i roja/magenta que representa l'origen de coordenades en l'eix vertical (y=0), i una vertical en verd, que representa l'origen de coordenades en l'eix horitzontal (x=0). Per tant, el personatge es troba en la posici\u00f3 (0,0).</p> <p>Aix\u00f2 ho podeu comprovar tamb\u00e9 en la propietat Transform/Position que hereta del Node2D.</p> <p>A m\u00e9s, si ampliem la pantalla, veurem que, junt amb aquests dos eixos, apareix un requadre en blau. Aquest requadre \u00e9s el ViewPort, \u00e9s a dir, l'espai de pantalla que veur\u00e0 l'usuari, i que hem definit a les propietats del projecte.</p> <p>Si feu clic al bot\u00f3 de reproduir l'escena actual (el Play dins la claqueta), veureu com el personatge apareix al cant\u00f3 superior esquerre.</p>"},{"location":"2.personatge/#lescena-playertest","title":"L'escena PlayerTest","text":"<p>Per tal d'ajustar els moviments del jugador, hem preparat una escena anomenada PlayerTest (<code>levels/PlayerTest.tscn</code>). Carregueu-la.</p> <p>Aquesta escena, consta d'un Node2D com a node principal, que a dins cont\u00e9 un node de tipus <code>TileMapLayer</code> anomenat <code>GroundLayer</code>. Els Tilemaps s\u00f3n, com diu el nom mapes de tiles que podriem traduir per rajolets, que no s\u00f3n m\u00e9s que imatges menudes que es combinen i repeteixen per formar un escenari.</p> <p>M\u00e9s sobre Tilemaps</p> <ul> <li>Tilemaps i TilemapLayer, als apunts de PMDM</li> </ul> <p>To-Do</p> <p>Ara el que volem \u00e9s incorporar el jugador a l'escena, o m\u00e9s b\u00e9, una inst\u00e0ncia del jugador.</p> <p>Per a aix\u00f2, amb aquesta escena oberta, nom\u00e9s caldr\u00e0 que busquem l'escena del jugador i l'arrosseguem a aquest aescena.</p> <p>Proveu a fer-ho, i feu clic en el bot\u00f3 de reproduir l'escena, per veure que tot es veu correctament.</p>"},{"location":"2.personatge/#afegint-funcionalitat-al-personatge","title":"Afegint Funcionalitat al Personatge","text":"<p>La funcionalitat als personatges s'incorpora mitjan\u00e7ant scripts amb el llenguatge GDScript.</p> <p>En Godot, cada node pot tindre associat com a molt un script per modelar el seu comportament. Aix\u00f2 s'aconsegueix amb el bot\u00f3 Attach Script.</p> <p>Compte</p> <p>Generalment, voldrem que totes les inst\u00e0ncies d'un tipus d'escena (Classe) tinguen el mateix comportament. Per aix\u00f2, l'script s'ha d'associar a l'escena o al node de l'escena que es desitge, i no a les inst\u00e0ncies concretes.</p> <p>Al nostre cas, per exemple, tot i que podr\u00edem afegir un script al jugador que hi ha dins l'escena, el que farem ser\u00e0 afegir l'script a l'escena Player en s\u00ed, i no a aquesta inst\u00e0ncia.</p> <p>Observeu que el node del Player que hem instanciat en aquesta escena cont\u00e9, en la finestra de l'arbre d'escena una icona d'una claqueta al costat. Fent clic en ella, podem editar l'escena del jugador.</p> <p>Aix\u00ed doncs afegim un script a l'escena del jugador per controlar aquest:</p> <p></p> <p>Com veieu, hem seleccionat una plantilla de moviment b\u00e0sic per a un CharacterBody2D, i hem guardat l'Script junt a l'escena del jugador.</p> <p>Com veureu, ha aparegut un nou s\u00edmbol al costat del node del jugador, indicant que aquest t\u00e9 un script associat. Aquest Script apareixer\u00e0 tant a l'escena del jugador com en totes les inst\u00e0ncies que fem d'ell.</p> <p>Com funcionen els scripts...?</p> <p>Abans d'examinar el codi dels scripts cal entendre una mica com funciona el bucle del joc.</p> <p>Quan executem un videojoc, aquest s'executa dins un bucle, que no s'atura fins que acaba el joc. Aquest bucle s'executa tantes vegades com Frames Per Segon (FPS) tinguem configurats (valors habituals s\u00f3n 30/60 FPS). Cada passada del bucle genera com a resultat un frame, \u00e9s a dir, la imatge que es mostra en pantalla, i per generar-la es fan moltes operacions pr\u00e8vies.</p> <p>Aquest bucle passa per diferents fases de manera ordenada, entre elles l'aplicaci\u00f3 de les f\u00edsiques, els c\u00e0lculs de col\u00b7lissions, renderitzats, etc. Durant l'execuci\u00f3 d'aquestes fases s'invoquen diferents funcions o m\u00e8todes dels Scripts que programem, a mode de callbacks.</p> <p>Per tant, la nostra tasca quan programem scripts en Godot \u00e9s la de preparar aquestes funcions per a que en cada fase es realitze all\u00f2 que desitgem.</p> <p>Feta aquesta aclaraci\u00f3, podeu examinar el codi de l'script que hem incorporat. Fixeu-vos en els seg\u00fcents detalls:</p> <ul> <li>Tot i que no definim una classe, estem estenent la funcionalitat d'un node, la qual cosa s'indica en la primera l\u00ednia amb <code>extends CharacterBody2D</code>. Amb aix\u00f2 heretem totes les propietats i m\u00e8todes del CharacterBody.</li> <li>Definim un parell de constants com SPEED i JUMP_VELOCITY (per qu\u00e8 aquesta \u00e9s negativa?).</li> <li>Implementem una funci\u00f3 <code>_physics_process</code>, que rep un par\u00e0metre <code>delta</code>. Aquesta funci\u00f3 s'invoca a cada pas d'actualitzaci\u00f3 de les f\u00edsiques. El par\u00e0metre delta indica els segons transcorreguts des de l\u2019anterior frame, la qual cosa ens serveix per fer animacions independents del framerate.</li> </ul> <p>Exemple pr\u00e0ctic sobre el framerate i delta</p> <p>Imagina que un joc es llan\u00e7a a 60FPS. Vol dir que en un segon el bucle es llan\u00e7a 60 vegades. Si en cada passada del bucle un personatge avan\u00e7a 1 p\u00edxel, al cap d'un segon haur\u00e0 avan\u00e7at 60 p\u00edxels.</p> <p>Ara b\u00e9, si el joc s'executa a 30FPS, qu\u00e8 passa? Quants p\u00edxels haur\u00e0 avan\u00e7at en 1s? La veloditat ser\u00e0 la mateixa?</p> <p>Si introduim un par\u00e0metre <code>delta</code>, que \u00e9s el temps que ha passat des que es va renderitzar l'\u00faltim frame, qu\u00e8 passar\u00e0? Amb 60FPS, <code>delta=1/60</code> (aprox 0.0167s), i a 30FPS, <code>delta=1/30</code> (aprox. 0.0333s).  Qu\u00e8 passa en cada cas, si fem que el personatge avance $60*delta$ p\u00edxels? Quant haur\u00e0 avan\u00e7at en 1 segon?</p> <ul> <li>Amb 60 FPS el personatge es mour\u00e0 60 * (1/60) = 1 p\u00edxel per frame, com esperem.</li> <li>Amb 30 FPS el personatge es mour\u00e0 60 * (1/30) = 2 p\u00edxels per frame, compensant la menor taxa de frames.</li> </ul> <p>Per tant: </p> <ul> <li>A 60 FPS, el personatge es mou 60 p\u00edxels en 1 segon, avan\u00e7ant 1 p\u00edxel per fotograma.</li> <li>A 30 FPS, el personatge es mou 60 p\u00edxels en 1 segon, avan\u00e7ant 2 p\u00edxels per fotograma, per mantindre la mateixa velocitat, gr\u00e0cies a l'ajustament per delta.</li> </ul> <p>Ara ja podeu entendre millor aquesta funci\u00f3 <code>_physycs_process</code>. Intenteu entendre qu\u00e8 fa, fent-vos les seg\u00fcents preguntes:</p> <ul> <li>Qu\u00e8 creieu que fa la funci\u00f3 <code>is_on_floor()</code>?</li> <li>Qu\u00e8 creieu que fa la funci\u00f3 `get_gravity()?</li> <li>I els m\u00e8todes <code>Input.is_action_just_pressed(\"ui_accept\")</code> i <code>Input.get_axis(\"ui_left\", \"ui_right\")</code>?</li> <li>I la funci\u00f3 <code>move_and_slide()</code>?</li> </ul> <p>Input per al salt</p> <p>L'script predeterminat per al moviment que hem afegit fa \u00fas dels cursors per al moviment horitzontal i de la tecla <code>ui_accept</code> (tecles d'Espai o Enter):</p> <pre><code>if Input.is_action_just_pressed(\"ui_accept\"):\n</code></pre> <p>Anem a reempla\u00e7ar aquesta per la fletxa del cursor cap amunt. Per aix\u00f2 reempla\u00e7em <code>ui_accept</code> per <code>ui_up</code>:</p> <pre><code>if Input.is_action_just_pressed(\"ui_up\"):\n</code></pre> <p>TO-DO</p> <p>Prova ara a llan\u00e7ar l'escena i comprova el funcionament. Intenta interactuar amb la plataforma que apareix a sobre. Has pogut fer-ho?</p> <p>Treballem una miqueta amb els TileMaps!</p>"},{"location":"2.personatge/#configurant-lescena","title":"Configurant l'escena","text":"<p>El node que representa el sol i les plataformes \u00e9s un node de tipus <code>TileMapLayer</code>, que cont\u00e9 una propietat <code>TileSet</code>, que \u00e9s el conjunt de Tiles o imatges que podem utilitzar per dissenyar les nostres pantalles.</p> <p>Si fem clic en el TileSet ens apareix a la part inferior la configuraci\u00f3 d'aquest. Al nostre exemple ja tenim importat el TileSet, pel que podem utilitzar-lo directament. Podeu llegir una miqueta de documentaci\u00f3 per veure com es fa aquest proc\u00e9s</p> <p>Si estem a la vista de disseny 2D i seleccionem el TileMap, podem pintar seleccionant els Tiles que volem i situant-los en l'escena.</p>"},{"location":"2.personatge/#configurant-collissions-al-tilemap","title":"Configurant col\u00b7lissions al Tilemap","text":"<p>Si volem que els tiles que afegim act\u00faen com a elements f\u00edsics i puguen detectar col\u00b7lissions, cal configurar-ho al TileMap.</p> <p>Per a aix\u00f2, seleccionem el <code>TileMapLayer</code> en q\u00fcesti\u00f3 (GroundLayer), i busquem a l'Inspector l'apartat Physics Layer el bot\u00f3 <code>Add Element</code>.</p> <p></p> <p>Com veurem, ara tenim el Tilemap en Collission Layer 1 i Collission Mask 1. Qu\u00e8 significa aix\u00f2?</p> <p></p> <p>Els physics Layers</p> <p>El sistema de Physics Layers ens permet controlar com interact\u00faen els objectes f\u00edsics en el joc, i per a aix\u00f2 necessitem capes i m\u00e0scares de col\u00b7lissi\u00f3. </p> <ul> <li>Collision Layer (Capa de Col\u00b7lisi\u00f3): Indica en quina capa o quines capes es troba un objecte. Un objecte pot estar en 32 capes com a m\u00e0xim. </li> <li>Collision Mask (M\u00e0scara de Col\u00b7lisi\u00f3): Indica amb quines capes pot col\u00b7lisionar un objecte.</li> </ul> <p>Aquest sistema ens dona m\u00e9s joc a l'hora d'establir els sistemes de col\u00b7lissi\u00f3. Per exemple, podem ubicar el jugador en la capa 1, i indicar com a m\u00e0scara la capa 2, on estiga per exemple el terreny i les plataformes, i la 3, on estan els enemics. Amb aix\u00f2, el jugador col\u00b7lissionar\u00e0 amb les plataformes i els enemics, per\u00f2 no amb altres jugadors.</p> <p>Si desitgem que un Tile puga col\u00b7lissionar, caldr\u00e0 dnar-li una forma. Aix\u00f2 ho podem fer des de la pestanya inferior de TileSet. Amb el Tile que volem seleccionat, a l'eina Selecciona buaixem fins arribar a l'apartat de Physics &gt; Physic Layer 0, des d'on podriem crear la forma de col\u00b7lissi\u00f3 que tindr\u00e0 el Tile, amb l'eina Edit points tool.</p> <p></p> <p>Si el que volem \u00e9s seleccionar la forma completa del rectangle del Tile, podem fer-ho des del men\u00fa dels tres puntets, i seleccionant Reset to Default tile Shape:</p> <p></p> <p>TO-DO</p> <p>Crea ara la forma per als Tiles de la plataforma, per a que puguen col\u00b7lissionar amb el jugador.</p>"},{"location":"2.personatge/#afegint-animacions-al-personatge","title":"Afegint Animacions al Personatge","text":"<p>Ara que tenim el moviment i una interacci\u00f3 b\u00e0sica amb l'entorn, \u00e9s el moment d'afegir les animacions. El node <code>AnimatedSprite2D</code> del personatge ja cont\u00e9 les animacions preconfigurades, per a l'estat de rep\u00f2s (iddle), caminar (run) i botar (jump).</p> <p>Aleshores, el que farem \u00e9s afegir una funci\u00f3 per gestionar les animacions en funci\u00f3 de l'estat del personatge (si est\u00e0 a terra, botant, corrent, etc.)</p> <p>En primer lloc, abans de les funcions declarem una refer\u00e8ncia al component AnimatedSprite2D:</p> <pre><code>@onready var animated_sprite = $AnimatedSprite2D\n</code></pre> <p>I despr\u00e9s definim el m\u00e8tode:</p> <pre><code>func update_animations():\n    if is_on_floor():\n        if velocity.x != 0:\n            animated_sprite.play(\"run\")\n        else:\n            animated_sprite.play(\"idle\")\n    else:\n        if velocity.y &lt; 0:\n            animated_sprite.play(\"jump\")\n        else:\n            animated_sprite.play(\"fall\")\n</code></pre> <p>Aquest m\u00e8tode s'invocar\u00e0 abans d'invocar el m\u00e8tode <code>move_and_slide</code> en <code>_physics_process</code>:</p> <pre><code>func _physics_process(delta: float) -&gt; void:\n    ...\n\n    # Actualitzar animacions\n    update_animations()\n\n    move_and_slide()\n</code></pre> <p>Si llancem l'escena, ara el jugador \u00e9s animat, per\u00f2 mira sempre cap a la dreta. Per tal que el personatge mire en la direcci\u00f3 en qu\u00e8 camina haurem d'afegir una xicoteta modificaci\u00f3.</p> <p>En primer lloc, definim una propietat que ens indique si mira cap a un o altre costat:</p> <pre><code>var mira_esquerra = false  # Variable per recordar l'\u00faltima direcci\u00f3 del moviment\n</code></pre> <p>I al final del m\u00e8tode que actualitza les animacions fem:</p> <pre><code>    if (velocity.x&lt;0):\n        mira_esquerra = true  # Recordem si ens movem cap a l'esquerra\n    elif (velocity.x)&gt;0:\n        mira_esquerra=false\n\n    animated_sprite.flip_h = mira_esquerra  # Flip horitzontal si es mou cap a l'esquerra\n</code></pre> <p>Com interpreteu el codi anterior...?</p> <ul> <li>Quines comprovacions estem fent?</li> <li>Qu\u00e8 fa la propietat <code>flip_h</code> del node AnimatedSprite2D?</li> </ul> <p>Late TO-DO: Doble salt</p> <p>Com podr\u00edem fer que el personatge poguera fer un doble salt?</p> <p>Algunes pistes:  - Crear una variable <code>double_jump</code> per controlar el doble salt.  - Quan el jugador estiga a l'aire i prema el bot\u00f3 de salt, permetrem un segon salt si <code>double_jump</code> est\u00e0 activat.</p>"},{"location":"3.enemics/","title":"3. Enemics","text":""},{"location":"3.enemics/#afegint-enemics-al-joc","title":"Afegint Enemics al Joc","text":"<p>Al projecte proporcionat ja disposeu d'una escena amb l'enemic (Characters/Enemy/enemic.tscn), amb la mateixa estructura que el jugador (CharacterBody2D, compost de AnimationSprite2D i CollissionShape2D).</p>"},{"location":"3.enemics/#escena-per-testejar-lenemic","title":"Escena per testejar l'enemic","text":"<p>Disposeu d'altra escena levels/EnemyTest.tscn amb un escenari amb l'enemic, per tal de treballarel seu moviment.</p> <p>TO-DO</p> <p>Arrossega l'escena de la tortuga a aquest nivell per comen\u00e7r a treballara mb ella.</p> <p>L'enemic es mour\u00e0 de manera autom\u00e0tica d'una banda a l'altra fins que col\u00b7lissione amb una paret. Si el personatge li bota a sobre, l'enemic mor, per\u00f2 si el personatge col\u00b7lissiona lateralment amb l'enemic, el jugador morir\u00e0 i es reiniciar\u00e0.</p> <p>Veiem com afegir aquest moviment a l'enemic. En aques cas anem a afegir un nou script buit, sense partir de cap plantilla, i afegirem el seg\u00fcent codi:</p> <pre><code>extends CharacterBody2D\n\nconst SPEED = 100  # Velocitat de l'enemic\nvar direction = -1 # Velocitat inicial: movent-se cap a l'esquerra\n\n@onready var animated_sprite = $AnimatedSprite2D  # Refer\u00e8ncia a l'AnimatedSprite\n\nfunc _ready() -&gt; void:\n    # Activem l'animacio\n    if(animated_sprite):    # Comprovem primer que estiga inicialitzat\n        animated_sprite.play(\"run\")\n\n# Funci\u00f3 que es crida cada fotograma\nfunc _physics_process(delta):\n    # Efecte de la gravetat\n    if not is_on_floor():\n        velocity += get_gravity() * delta\n\n    # Movem l'enemic en la direcci\u00f3 definida\n    velocity.x = direction * SPEED\n\n    # Ajustem el flip horitzontal\n    animated_sprite.flip_h = velocity.x&gt;0 # Flip horitzontal si es mou cap a l'esquerra\n\n    # Movem l'enemic\n    move_and_slide()\n\n    # Si col\u00b7lideix amb una paret, canviem de direcci\u00f3\n    # Es important comprovar a\u00e7o despres del move_and_slide\n    if is_on_wall():\n        direction = -direction  # Canviem la direcci\u00f3 (de dreta a esquerra o viceversa)\n</code></pre> <p>El codi \u00e9s similar al del moviment del pesonatge. Observeu que ara implementem les funcions del bucle del joc <code>_ready()</code>, que es dispara quan el node es troba instanciat i preparat, i <code>_physics_process()</code>, per tal de processar les f\u00edsiques.</p> <p>Despr\u00e9s comprovem si no est\u00e0 tocant el terra, per aplicar-li la gravetat, ajustem el flip en horitzontal i movem el node amb <code>move_and_slide()</code>. Una vegada s'ha mogut, \u00e9s possible que col\u00b7lissione amb alguna paret, de manera que ho comprovem amb <code>is_on_wall()</code>. Si \u00e9s aix\u00ed, simplement fem que canvie de direcci\u00f3.</p> <p>!!!note <code>is_on_wall()</code> i <code>is_on_floor()</code>      Aquests s\u00f3n dos m\u00e8todes especialitzats per a la detecci\u00f3 de col\u00b7lissions. En general, quan es detecten col\u00b7lissions, necessitem saber el sentit en qu\u00e8 s'han produit, ja que no \u00e9s el mateix caure sobre un enemic per eliminar-lo que xocar contra ell, cas al qual mor el personatge.</p> <pre><code> En tots dos casos es produeix una col\u00b7lissi\u00f3, per\u00f2 en el primer es fa en sentit vertical, i en el segon en horitzontal.\n\n  Aquest sentit ve determinat pel vector *normal* a la col\u00b7lissi\u00f3, un vector perpendicular a la superf\u00edcie de la col\u00b7lissi\u00f3. Si la normal \u00e9s m\u00e9s o menys *vertical*, sabem que el personatge est\u00e0 tocant el terra, mentre que si la normal \u00e9s m\u00e9s o menys *horitzontal*, el personatge est\u00e0 tocant una paret o un enemic.\n\n  Les funcions `is_on_floor()` i `is_on_wall` utilitzen aquesta normal internament, i ens simplifiquen la feina de detectar col\u00b7lissions en sentit vertical o horitzontal.\n</code></pre> <p>Si ara llancem l'escena, veurem que la tortuga canvia de sentit quan col\u00b7lissiona horitzontalment amb qualsevol element (personatge incl\u00f2s).</p> <p>Ara ens queda detectar les col\u00b7lissions amb el jugador. Per a aix\u00f2 ja necessitarem fer \u00fas del vector normal en lloc de <code>is_on_wall()</code>. Aix\u00ed, que eliminem el seg\u00fcent fragment de codi:</p> <pre><code>if is_on_wall():\n    direction = -direction  # Canviem la direcci\u00f3 (de dreta a esquerra o viceversa)\n</code></pre> <p>I incorporem el seg\u00fcent:</p> <pre><code>var collission= get_slide_collision(0)\nif collission:\n    var objecteCollissionat=collission.get_collider()\n    var collision_normal = collission.get_normal()  # Normal de la col\u00b7lisi\u00f3\n\n    # Si l'objecte col\u00b7lisionat \u00e9s una paret (normal horitzontal)\n    if collision_normal.x != 0:\n        direction = -direction  # Invertim la direcci\u00f3 (de dreta a esquerra o viceversa)\n\n    # Si l'objecte col\u00b7lisionat \u00e9s el jugador\n    if objecteCollissionat.is_in_group(\"player\"):\n\n        if collision_normal.y &gt; 0:  # Si el jugador est\u00e0 caient sobre l'enemic\n            queue_free()  # Eliminar l'enemic\n        else:  # Si el jugador col\u00b7lideix lateralment amb l'enemic\n            print(\"mata jugador\")\n            get_tree().call_group(\"player\", \"reset_position\")  # El jugador torna a la posici\u00f3 original\n</code></pre> <p>Examinem algunes de les claus d'aquest codi.</p> <pre><code>var collission = get_slide_collision(0)\n</code></pre> <p>Amb <code>get_slide_collision(0)</code> obtenim la primera col\u00b7lisi\u00f3 que s'ha produ\u00eft des de l'\u00faltima crida a <code>move_and_slide()</code>. L'objecte que ens retorna cont\u00e9 informaci\u00f3 detallada sobre la col\u00b7lisi\u00f3, de la qual necessitarem el cos amb qu\u00e8 hem col\u00b7lisionat i la normal de la col\u00b7lisi\u00f3. </p> <p>Aix\u00ed:</p> <ul> <li>Amb <code>collission.get_collider()</code> obtenim l'objecte amb el qu\u00e8 s'ha col\u00b7lissionat.</li> <li>Amb <code>collission.get_normal()</code> obtenim el vector normal a la col\u00b7lissi\u00f3.</li> </ul> <p>El vector normal ens indica la direcci\u00f3 perpendicular al punt de la superf\u00edcie on s'ha produit la col\u00b7lissi\u00f3. Aix\u00ed, si la normal \u00e9s horitzontal indica que la col\u00b7lissi\u00f3 s'ha produit amb una paret vertical, per tant, seria l'equivalent al <code>is_in_wall()</code>:</p> <pre><code>if collision_normal.x != 0:\n    direction = -direction  # Invertim la direcci\u00f3 (de dreta a esquerra o viceversa)\n</code></pre> <p>Ara cal comprovar si l'objecte amb el que s'ha produit la col\u00b7lissi\u00f3 \u00e9s el jugador. Per a aix\u00f2, introdu\u00efm els grups.</p> <p>Note</p> <p>Els grups en Godot s\u00f3n una manera de classificar nodes per poder gestionar-los conjuntament. Aix\u00f2 permet realitzar operacions a tots els nodes d'un grup de manera senzilla, com cridar un m\u00e8tode o aplicar un canvi.</p> <p>A m\u00e9s, podem comprovar si un node forma part d'un grup amb el m\u00e8tode <code>is_in_group(\"nom_grup\")</code>.</p> <p>Aix\u00ed, abans de comprovar si es col\u00b7lissiona amb el jugador, anem a afegir aquest al grup player.</p> <p>Per a aix\u00f2, **obrim l'script del jugador, <code>player.gd</code>, i afegim la seg\u00fcent funci\u00f3 <code>_ready()</code>:</p> <pre><code> func _ready():\n    self.add_to_group(\"player\")\n</code></pre> <p>Aix\u00ed ara, amb <code>objecteCollissionat.is_in_group(\"player\")</code> podem sabe si s'ha col\u00b7lissionat amb el jugador. Si \u00e9s aix\u00ed, comprovem si la normal \u00e9s vertical, el que indicaria que el jugador ha saltat a sobre l'enemic.</p> <p>Despr\u00e9s, la funci\u00f3 <code>queue_free()</code> el que fa \u00e9s eliminar l'objecte de l'escena, i <code>get_tree.call_group())</code> el que fa \u00e9s invocar un m\u00e8tode concret sobre tots els objectes d'un grup, en aquest cal, la funci\u00f3 reset_position dels objectes del grup player.</p> <p>Aquest funci\u00f3 reset_position no existeix encara al jugador, pel que haurem d'editar de nou el fitxer <code>player.gd</code> i afegir aquesta funci\u00f3:</p> <pre><code>func reset_position():\n    position=Vector2(400, 225)\n</code></pre>"},{"location":"4.todo/","title":"4. Mans a l'obra","text":""},{"location":"4.todo/#crea-el-teu-nivell","title":"Crea el teu nivell!","text":"<p>Ara et toca a tu crear un nivell jugable complet, amb l'escenari, els enemics, i dos jugadors. Per a aix\u00f2, segueix els seg\u00fcent pasos.</p>"},{"location":"4.todo/#pas-1-creacio-de-lescena-i-el-tilemap","title":"Pas 1. Creaci\u00f3 de l'escena i el TileMap","text":"<ol> <li>Crea una nova escena (Escena &gt; Nova Escena), i afig com a arrel un Node2D.</li> <li>Afig com a fill un TileMapLayer</li> <li>Amb el TileMapLayer seleccionat, des de l'Inspector, associa-li un nou TileSet.</li> <li>Selecciona el TileSet a l'Inspector i accedeix a la pestanya TileSet de la part inferior.</li> <li>Busca en l'explorador de recursos el recurs <code>assets/Mario1/TileSets/OverWorld.png</code> i arrossega'l a la finestra <code>TileSource</code>. Quan se't pregunte per la creaci\u00f3 autom\u00e0tica de l'Atlas, indica que s\u00ed.</li> <li>Fes \u00fas de les eines de dibuix per dissenyar el nivell.</li> <li>No t'oblides de generar la capa Physics Layer des de l'editor i definir la forma dels Tiles des del TileSet!</li> </ol>"},{"location":"4.todo/#pas-2-afig-el-jugador-principal-un-un-segon-jugador","title":"Pas 2. Afig el jugador principal un un segon jugador","text":"<ol> <li>Arrossega l'escena del Player on desitges que comence aquest</li> <li>Dispose tamb\u00e9 d'una escena <code>player2.tscn</code>, que cont\u00e9 un altre jugador. Afig-lo tamb\u00e9 a l'escena.</li> <li> <p>El Player2 no t\u00e9 un script associat encara, aix\u00ed que edita l'escena del jugador i afig-li un Script. Aquest script ser\u00e0 na c\u00f2pia de l'script del jugador1, amb les seg\u00fcents difer\u00e8ncies:</p> <ul> <li>Modifica la l\u00ednia per detercar el bot:</li> </ul> <pre><code># Modifiquem aquesta l\u00ednia\nif Input.is_action_just_pressed(\"ui_up\"):\n\n# Per aquesta altra:\nif Input.is_action_just_pressed(\"ui_up_player2\"): \n</code></pre> <p>El control <code>ui_up_player2</code> ja s'ha configurat al projecte que se us proporciona amb la tecla <code>W</code>.</p> <ul> <li>Modifica les l\u00ednies pe detectar el moviment horitzontal:</li> </ul> <pre><code># Modifiquem la l\u00ednia:\n\nvar direction := Input.get_axis(\"ui_left\", \"ui_right\")\n\n# Pel seg\u00fcent codi:\n\n# Agafem la direccio\nvar direction := 0  # Default to no movement\n\nif Input.is_action_pressed(\"ui_left_player2\"):  # Configurat per a A\n    direction = -1\nelif Input.is_action_pressed(\"ui_right_player2\"):  # Configurat per a D\n    direction = 1\n</code></pre> </li> </ol>"},{"location":"4.todo/#pas-3-afegir-enemics","title":"Pas 3. Afegir enemics","text":"<p>Finalment, arrossega el personatge enemic per tal de crear v\u00e0ries inst\u00e0ncies d'aquest.</p> <p>Aci tens un exemple de com pot quedar aquest nivell:</p> <p></p>"}]}